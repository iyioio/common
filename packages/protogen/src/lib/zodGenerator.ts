import { ProtoContext, ProtoNode } from "./protogen-types";

export interface ZodGeneratorOptions
{
    /**
     * @arg --zod-def-prefix
     */
    defPrefix?:string;
    /**
     * @arg --zod-def-suffix
     */
    defSuffix?:string;
}

export const zodGenerator=async ({
    nodes,
    outputs,
    args,
    tab,
}:ProtoContext)=>{

    const options:Required<ZodGeneratorOptions>={
        defPrefix:args['--zod-def-prefix']?.[0]??'',
        defSuffix:args['--zod-def-suffix']?.[0]??'Scheme',
    }
    const {
        defPrefix,
        defSuffix
    }=options;

    const getFullName=(name:string)=>`${defPrefix}${name}${defSuffix}`;

    const out:string[]=[];

    const useCustomTypes:CustomBuiltInsType[]=[];

    out.push(`// this file was autogenerated by @iyio/protogen - https://github.com/iyioio/common/packages/protogen`);
    out.push(`// generator = zodGenerator`);
    out.push(`import { z } from 'zod';`);

    for(const node of nodes){

        const tsType:'interface'|'union'|'enum'=(
            node.refType?.type==='enum'?
                (node.types[2]?.type==='string'?'union':'enum')
            :node.refType?.type==='union'?
                'union'
            :'interface'
        )

        switch(tsType){

            case 'interface':
                addInterface(node,out,tab,getFullName,useCustomTypes);
                break;

            case 'union':
                addUnion(node,out,tab,getFullName);
                break;

            case 'enum':
                addEnum(node,out,tab,getFullName);
                break;
        }


    }

    outputs.push({
        ext:'ts',
        content:out.join('\n'),
    })
}

const addEnum=(node:ProtoNode,out:string[],tab:string,getFullName:(name:string)=>string)=>{

    const fullName=getFullName(node.name);

    const children=node.children??[];

    out.push('');
    out.push(`export enum ${node.name}{`);

    for(const child of children){
        out.push(`${tab}${child.name}${child.type?'='+child.type:''},`)
    }

    out.push('}')

    out.push(`export const ${fullName}=z.nativeEnum(${node.name})`);
}

const addUnion=(node:ProtoNode,out:string[],tab:string,getFullName:(name:string)=>string)=>{

    const fullName=getFullName(node.name);


    out.push('');
    out.push(`export const ${fullName}=z.enum([`);

    const children=node.children??[];
    for(const child of children){
        out.push(`${tab}${JSON.stringify(child.name)},`)
    }

    out.push(`]);`);
    out.push(`export type ${node.name}=z.infer<typeof ${fullName}>;`);
}

const addInterface=(node:ProtoNode,out:string[],tab:string,getFullName:(name:string)=>string,useCustomTypes:CustomBuiltInsType[])=>{
    const fullName=getFullName(node.name);

    const hasCustoms=node.children?.some(c=>!isBuiltInType(c.type))?true:false;

    out.push('');
    if(hasCustoms){
        out.push(`const __base__${fullName}=z.object({`);
    }else{
        out.push(`export const ${fullName}=z.object({`);
    }
    const interfaceProps:string[]=[];
    const lazyProps:string[]=[];

    if(node.children){
        for(const prop of node.children){

            const isBuiltIn=isBuiltInType(prop.type);

            if(!isBuiltIn){
                interfaceProps.push(`${
                        prop.comment?formatComment(prop.comment,tab):''
                    }${
                        tab
                    }${
                        prop.name
                    }${
                        prop.optional?'?':''
                    }:${
                        prop.type
                    };`
                );
                lazyProps.push(`${
                        tab
                    }${
                        prop.name
                    }:z.lazy(()=>${
                        getFullName(prop.type)
                    })${
                        prop.optional?'.optional()':''
                    },`
                );
                continue;
            }

            const customType=getRealCustomType(prop.type as any);
            if(customType && !useCustomTypes.includes(prop.type as any)){
                useCustomTypes.push(prop.type as any)
            }

            out.push(`${
                    prop.comment?formatComment(prop.comment,tab):''
                }${
                    tab
                }${
                    prop.name
                }:${
                    customType||`z.${prop.type}()`
                }${
                    prop.isArray?'.array()':''
                }${
                    prop.optional?'.optional()':''
                },`
            );
        }
    }

    out.push('});');
    if(hasCustoms){
        out.push(`export const ${fullName}=z.object({`);
        for(const prop of lazyProps){
            out.push(prop);
        }
        out.push('});')
    }
    if(interfaceProps.length){
        out.push(`export type ${node.name}=z.infer<typeof ${hasCustoms?'__base__':''}${fullName}> & {`);

        for(const prop of interfaceProps){
            out.push(prop);
        }

        out.push('};')
    }else{
        out.push(`export type ${node.name}=z.infer<typeof ${hasCustoms?'__base__':''}${fullName}>;`);
    }
}

const customBuiltIns=['StringMap','NumberMap','BooleanMap','DateMap','BigIntMap'] as const;
type CustomBuiltInsType=typeof customBuiltIns[number];
const getRealCustomType=(type:CustomBuiltInsType)=>{
    switch(type){
        case 'StringMap': return 'z.record(z.string())';
        case 'NumberMap': return 'z.record(z.number())';
        case 'BooleanMap': return 'z.record(z.boolean())';
        case 'DateMap': return 'z.record(z.date())';
        case 'BigIntMap': return 'z.record(z.bigint())';
        default: return null;
    }
}
const builtIns=['string','number','any','bigint','boolean','date','null'] as const
const isBuiltInType=(type:string)=>{
    return builtIns.includes(type as any) || customBuiltIns.includes(type as any);
}

const formatComment=(comment:string,tab:string)=>(
    `${tab}/**\n${tab} * ${comment.split('\n').join(`\n${tab} * `)}\n${tab} */\n`
)
